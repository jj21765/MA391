Outer = function(f,x){
  n1 = length(x[[1]])
  n2 = length(x[[2]])
  res = matrix(0,nrow=n1,ncol=n2)
  rownames(res) = x[[1]]
  colnames(res) = x[[2]]
  for (i in 1:n1){
    for (j in 1:n2){
      res[i,j]=f(c(x[[1]][[i]],x[[2]][[j]]))
    }
  }
  return(res)
}

help(Outer)

#Help(Outer)
###Number3###
obj=function(x){(10*x[1]^(0.6)*x[2]^(0.4)*(-1))}
#multiply by -1 for maximizing

##contour plot
X=list(x=seq(0,20,0.1),y=seq(0,20,0.1))
Z=Outer(obj,X)
contour(x=X$x,y=X$y,z=-Z,lwd=3)#lwd=3,make z=-Z to make it positive again
#idk what the dollar signs are
#lwd is line width 

#horizontal line or vertical line , do 
#abline(a=,b=,h=,v=) the h is horizontal, v is vertical
abline(a=10,b=-5/3,col="red")

contour(x=X$x,y=X$y,z=-Z,lwd=1,
        levels=c(20,37,55,60,80,100,120,140) )
abline(a=10,b=-5/3,col="red")
##where the red line meets the contour plot is the 
#maximization of the values (2 variable?)
#gradient vectors... 
#here, the constraint comes from the equation
#50x[1]+30x[2]=300

##command: solnl?
library(MASS);library(NlcOptim)
x0=c(3,5) ##could be any valuable to make 50x[1]+30x[2]=300
Aeq=matrix(c(50,30),nrow=1)
#c is for coefficients
#theres two columns cuz two variables
Beq=matrix(300)
ans=solnl(x0,obj,Aeq=Aeq,Beq=Beq)
print(ans)
#solves for lambda too 

###Number 1###
obj=function(x){((1/2)*(x[2]-32)*(x[1]^2))*(-1)}
con=function(x){
  f=NULL #clears everything out of f, just in case
  #you ran it earlier or somewhere else
  #f is the constraint? 
  f=rbind(f,x[2]^2*x[1]-10000)
  #binds, creates a new row
  #here its the u^2 or x[2]^2, and this creates the constraint
  return(list(ceq=f,c=NULL))
  #ceq is the constraint equations
}
x0=c(1,100)
#heres the starting conditions, it needs to solve
#your constraint
solnl(x0,objfun=obj,confun=con)
